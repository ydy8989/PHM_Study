# 7월 2주차

## Refer. Link

- https://mapr.com/blog/real-time-anomaly-detection-2/ : 무슨 h2o 아노말리?

- https://github.com/khundman/telemanom : 아래 사진 참고.
  ![1562637942938](https://github.com/ydy8989/PHM_Study/blob/master/pic/1562637942938.png)



- https://bcho.tistory.com/1198?category=555440 : auto encoder조대협

---

## TODO List

- ~~붙여서 테스트 해볼려고 시도해봄~~ >> 실패

- Feature engineering

  - 범주형 데이터와, 아닌것과 구분지을 필요 있음. 그래야 평균내는 의미가 있다...

  - ~~스테이지바뀔때 발생하는 빈시간 데이터 없애기.~~

    - ~~생각해보니 이럴 필요가 없음. 어차피 실제 테이블에는 없는 시간이라 텐서에 들어가지 않음.~~

  - ~~Tumbling aggregates : 구간 1개 당 한 번씩 평균내면서 전체 구간을 단위 구간만큼 나눈 사이즈로 축소하기~~ >> 완료

    ```python
    def Tumbling(sensor_data, divide_num):
        print('==================================================')
        print('Tumbling aggregates processing...................')
        print('==================================================')
        print(' ')
        #타임 컬럼 인덱스로
        sensor_data.index = pd.to_datetime(sensor_data.time, unit = 's')
        sensor_data = sensor_data.drop(['time'], axis = 1)
        
        #중복행 처리 : 인덱스 기준
        sensor_data = sensor_data.drop_duplicates()
    
        #범주형 데이터 컬럼 제거 
        no_cat_sensor = sensor_data.ix[:,4:]
        #인덱스는 divide_num의 첫번째 인덱스로 대표
        
        idx_lst = []
        a = []
        for idx, time in enumerate(no_cat_sensor.index):
            if idx % divide_num == 0:
                print('{}-th index / {} total, Tumbling aggregates processing...'.format(idx, len(no_cat_sensor)))
                idx_lst.append(time)
                a.append(no_cat_sensor[idx:idx+10].apply(lambda x:sum(x)/divide_num, axis = 0))
        tumble_df = pd.DataFrame(a, index = idx_lst)
        return tumble_df
    ```
    
  - 이동평균선 만들어서(예를들면 한시간 간격?) 튀어 나가는 범주를 계산하게끔 만들어 준다. !!!! 
  
    - 사실상 lstm 주가 예측 백테스팅 프로그램 부분이랑 굉장히 비슷할거같다...
  
  - 
  
- 전체 데이터 학습 모듈 만들기

  - ~~tumbling aggregates~~

- Auto-Encoder playing



## 새로운 발견.st (a.k.a 킹리적 갓심)

1. 데이터는 연속된 것이 아니었다....

2. 하나의 파일은 하나의 기기에 대한 센서 데이터였다. 

   

## Insight

1. LSTM의 학습 방식에 대한 견해
   1. 전체 Sequence를 예측하기  
      - 장점 : 시계의 추이를 예측하기 쉽고, 시각화 했을 때, 
      - 단점 



## mind flow

- 리뷰

- 이번주

  - tumbling aggregate 시도 (다운 샘플링하기 300만 => 30만개)

  - lstm 모든 파일 합치기

    - 문제점 : 타임라인이 세부 Tool 이라는 column을 기준으로 나뉘어져 있었음. 즉 파일마다 시계열이 연결된 것이 아님

    - Sequence prediction 방식 : 

      - 전체 시퀀스 output을 1차원 형식으로 예측하기 위한 전처리 방식 : 

        ```
        파일로드
        cutoff
        series to supervised
        normalization
        lst에 append
        ```

        

    - Classification 방식 : 

      - 파일별 시계 정보를 무시하고, 학습시키기.

      - Multi Classification labeling

        ![multiclassification](C:\Users\hbee\PycharmProjects\PHM_Study\pic\multiclassification.PNG)

        - 이 경우의 문제점 ; label 0 값이 너무 많이 나옴

          ```
          하루안에 고장 : 레이블 2
          일주일 안에 고장 : 레이블 1
          일주일 안에 고장 안남 : 레이블 0 
          ```

          